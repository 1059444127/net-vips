// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace NetVips.AutoGen
{
    [Flags]
    public enum VipsArgumentFlags
    {
        VIPS_ARGUMENT_NONE = 0,
        VIPS_ARGUMENT_REQUIRED = 1,
        VIPS_ARGUMENT_CONSTRUCT = 2,
        VIPS_ARGUMENT_SET_ONCE = 4,
        VIPS_ARGUMENT_SET_ALWAYS = 8,
        VIPS_ARGUMENT_INPUT = 16,
        VIPS_ARGUMENT_OUTPUT = 32,
        VIPS_ARGUMENT_DEPRECATED = 64,
        VIPS_ARGUMENT_MODIFY = 128
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr VipsArgumentMapFn(global::System.IntPtr @object, global::System.IntPtr pspec, global::System.IntPtr argument_class, global::System.IntPtr argument_instance, global::System.IntPtr a, global::System.IntPtr b);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr VipsArgumentClassMapFn(global::System.IntPtr object_class, global::System.IntPtr pspec, global::System.IntPtr argument_class, global::System.IntPtr a, global::System.IntPtr b);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr VipsObjectSetArguments(global::System.IntPtr @object, global::System.IntPtr a, global::System.IntPtr b);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr VipsTypeMapFn(ulong type, global::System.IntPtr a);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr VipsTypeMap2Fn(ulong type, global::System.IntPtr a, global::System.IntPtr b);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr VipsClassMapFn(global::System.IntPtr cls, global::System.IntPtr a);

    public unsafe partial class VipsObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NetVips.AutoGen.GObject.__Internal parent_instance;

            [FieldOffset(24)]
            internal int constructed;

            [FieldOffset(28)]
            internal int static_object;

            [FieldOffset(32)]
            internal global::System.IntPtr argument_table;

            [FieldOffset(40)]
            internal global::System.IntPtr nickname;

            [FieldOffset(48)]
            internal global::System.IntPtr description;

            [FieldOffset(56)]
            internal int preclose;

            [FieldOffset(60)]
            internal int close;

            [FieldOffset(64)]
            internal int postclose;

            [FieldOffset(72)]
            internal ulong local_memory;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NetVips.AutoGen.VipsObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NetVips.AutoGen.VipsObject>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::NetVips.AutoGen.VipsObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::NetVips.AutoGen.VipsObject(native.ToPointer(), skipVTables);
        }

        internal static global::NetVips.AutoGen.VipsObject __CreateInstance(global::NetVips.AutoGen.VipsObject.__Internal native, bool skipVTables = false)
        {
            return new global::NetVips.AutoGen.VipsObject(native, skipVTables);
        }

        private static void* __CopyValue(global::NetVips.AutoGen.VipsObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NetVips.AutoGen.VipsObject.__Internal));
            *(global::NetVips.AutoGen.VipsObject.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VipsObject(global::NetVips.AutoGen.VipsObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VipsObject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        ~VipsObject()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::NetVips.AutoGen.VipsObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NetVips.AutoGen.GObject ParentInstance
        {
            get
            {
                return global::NetVips.AutoGen.GObject.__CreateInstance(new global::System.IntPtr(&((global::NetVips.AutoGen.VipsObject.__Internal*) __Instance)->parent_instance));
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObject.__Internal*)__Instance)->parent_instance = ReferenceEquals(value, null) ? new global::NetVips.AutoGen.GObject.__Internal() : *(global::NetVips.AutoGen.GObject.__Internal*) value.__Instance;
            }
        }

        public int Constructed
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsObject.__Internal*) __Instance)->constructed;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObject.__Internal*)__Instance)->constructed = value;
            }
        }

        public int StaticObject
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsObject.__Internal*) __Instance)->static_object;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObject.__Internal*)__Instance)->static_object = value;
            }
        }

        public char* Nickname
        {
            get
            {
                return (char*) ((global::NetVips.AutoGen.VipsObject.__Internal*) __Instance)->nickname;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObject.__Internal*)__Instance)->nickname = (global::System.IntPtr) (sbyte*) value;
            }
        }

        public char* Description
        {
            get
            {
                return (char*) ((global::NetVips.AutoGen.VipsObject.__Internal*) __Instance)->description;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObject.__Internal*)__Instance)->description = (global::System.IntPtr) (sbyte*) value;
            }
        }

        public int Preclose
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsObject.__Internal*) __Instance)->preclose;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObject.__Internal*)__Instance)->preclose = value;
            }
        }

        public int Close
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsObject.__Internal*) __Instance)->close;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObject.__Internal*)__Instance)->close = value;
            }
        }

        public int Postclose
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsObject.__Internal*) __Instance)->postclose;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObject.__Internal*)__Instance)->postclose = value;
            }
        }

        public ulong LocalMemory
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsObject.__Internal*) __Instance)->local_memory;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObject.__Internal*)__Instance)->local_memory = value;
            }
        }
    }

    public unsafe partial class VipsObjectClass : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 328)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NetVips.AutoGen.GObjectClass.__Internal parent_class;

            [FieldOffset(136)]
            internal global::System.IntPtr build;

            [FieldOffset(144)]
            internal global::System.IntPtr postbuild;

            [FieldOffset(152)]
            internal global::System.IntPtr summary_class;

            [FieldOffset(160)]
            internal global::System.IntPtr summary;

            [FieldOffset(168)]
            internal global::System.IntPtr dump;

            [FieldOffset(176)]
            internal global::System.IntPtr sanity;

            [FieldOffset(184)]
            internal global::System.IntPtr rewind;

            [FieldOffset(192)]
            internal global::System.IntPtr preclose;

            [FieldOffset(200)]
            internal global::System.IntPtr close;

            [FieldOffset(208)]
            internal global::System.IntPtr postclose;

            [FieldOffset(216)]
            internal global::System.IntPtr new_from_string;

            [FieldOffset(224)]
            internal global::System.IntPtr to_string;

            [FieldOffset(232)]
            internal int output_needs_arg;

            [FieldOffset(240)]
            internal global::System.IntPtr output_to_arg;

            [FieldOffset(248)]
            internal global::System.IntPtr nickname;

            [FieldOffset(256)]
            internal global::System.IntPtr description;

            [FieldOffset(264)]
            internal global::System.IntPtr argument_table;

            [FieldOffset(272)]
            internal global::System.IntPtr argument_table_traverse;

            [FieldOffset(280)]
            internal ulong argument_table_traverse_gtype;

            [FieldOffset(288)]
            internal int deprecated;

            [FieldOffset(296)]
            internal global::System.IntPtr _vips_reserved1;

            [FieldOffset(304)]
            internal global::System.IntPtr _vips_reserved2;

            [FieldOffset(312)]
            internal global::System.IntPtr _vips_reserved3;

            [FieldOffset(320)]
            internal global::System.IntPtr _vips_reserved4;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NetVips.AutoGen.VipsObjectClass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NetVips.AutoGen.VipsObjectClass>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::NetVips.AutoGen.VipsObjectClass __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::NetVips.AutoGen.VipsObjectClass(native.ToPointer(), skipVTables);
        }

        internal static global::NetVips.AutoGen.VipsObjectClass __CreateInstance(global::NetVips.AutoGen.VipsObjectClass.__Internal native, bool skipVTables = false)
        {
            return new global::NetVips.AutoGen.VipsObjectClass(native, skipVTables);
        }

        private static void* __CopyValue(global::NetVips.AutoGen.VipsObjectClass.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NetVips.AutoGen.VipsObjectClass.__Internal));
            *(global::NetVips.AutoGen.VipsObjectClass.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VipsObjectClass(global::NetVips.AutoGen.VipsObjectClass.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VipsObjectClass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        ~VipsObjectClass()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::NetVips.AutoGen.VipsObjectClass __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int OutputNeedsArg
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsObjectClass.__Internal*) __Instance)->output_needs_arg;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObjectClass.__Internal*)__Instance)->output_needs_arg = value;
            }
        }

        public string Nickname
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::NetVips.AutoGen.VipsObjectClass.__Internal*) __Instance)->nickname);
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObjectClass.__Internal*)__Instance)->nickname = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string Description
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::NetVips.AutoGen.VipsObjectClass.__Internal*) __Instance)->description);
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObjectClass.__Internal*)__Instance)->description = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public ulong ArgumentTableTraverseGtype
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsObjectClass.__Internal*) __Instance)->argument_table_traverse_gtype;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObjectClass.__Internal*)__Instance)->argument_table_traverse_gtype = value;
            }
        }

        public int Deprecated
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsObjectClass.__Internal*) __Instance)->deprecated;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsObjectClass.__Internal*)__Instance)->deprecated = value;
            }
        }
    }

    public unsafe partial class VipsArgument : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr pspec;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NetVips.AutoGen.VipsArgument> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NetVips.AutoGen.VipsArgument>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::NetVips.AutoGen.VipsArgument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::NetVips.AutoGen.VipsArgument(native.ToPointer(), skipVTables);
        }

        internal static global::NetVips.AutoGen.VipsArgument __CreateInstance(global::NetVips.AutoGen.VipsArgument.__Internal native, bool skipVTables = false)
        {
            return new global::NetVips.AutoGen.VipsArgument(native, skipVTables);
        }

        private static void* __CopyValue(global::NetVips.AutoGen.VipsArgument.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NetVips.AutoGen.VipsArgument.__Internal));
            *(global::NetVips.AutoGen.VipsArgument.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VipsArgument(global::NetVips.AutoGen.VipsArgument.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VipsArgument(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        ~VipsArgument()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::NetVips.AutoGen.VipsArgument __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NetVips.AutoGen.GParamSpec Pspec
        {
            get
            {
                global::NetVips.AutoGen.GParamSpec __result0;
                if (((global::NetVips.AutoGen.VipsArgument.__Internal*) __Instance)->pspec == IntPtr.Zero) __result0 = null;
                else if (global::NetVips.AutoGen.GParamSpec.NativeToManagedMap.ContainsKey(((global::NetVips.AutoGen.VipsArgument.__Internal*) __Instance)->pspec))
                    __result0 = (global::NetVips.AutoGen.GParamSpec) global::NetVips.AutoGen.GParamSpec.NativeToManagedMap[((global::NetVips.AutoGen.VipsArgument.__Internal*) __Instance)->pspec];
                else __result0 = global::NetVips.AutoGen.GParamSpec.__CreateInstance(((global::NetVips.AutoGen.VipsArgument.__Internal*) __Instance)->pspec);
                return __result0;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgument.__Internal*)__Instance)->pspec = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class VipsArgumentClass : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NetVips.AutoGen.VipsArgument.__Internal parent;

            [FieldOffset(8)]
            internal global::System.IntPtr object_class;

            [FieldOffset(16)]
            internal global::NetVips.AutoGen.VipsArgumentFlags flags;

            [FieldOffset(20)]
            internal int priority;

            [FieldOffset(24)]
            internal uint offset;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NetVips.AutoGen.VipsArgumentClass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NetVips.AutoGen.VipsArgumentClass>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::NetVips.AutoGen.VipsArgumentClass __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::NetVips.AutoGen.VipsArgumentClass(native.ToPointer(), skipVTables);
        }

        internal static global::NetVips.AutoGen.VipsArgumentClass __CreateInstance(global::NetVips.AutoGen.VipsArgumentClass.__Internal native, bool skipVTables = false)
        {
            return new global::NetVips.AutoGen.VipsArgumentClass(native, skipVTables);
        }

        private static void* __CopyValue(global::NetVips.AutoGen.VipsArgumentClass.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NetVips.AutoGen.VipsArgumentClass.__Internal));
            *(global::NetVips.AutoGen.VipsArgumentClass.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VipsArgumentClass(global::NetVips.AutoGen.VipsArgumentClass.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VipsArgumentClass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        ~VipsArgumentClass()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::NetVips.AutoGen.VipsArgumentClass __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NetVips.AutoGen.VipsArgument Parent
        {
            get
            {
                return global::NetVips.AutoGen.VipsArgument.__CreateInstance(new global::System.IntPtr(&((global::NetVips.AutoGen.VipsArgumentClass.__Internal*) __Instance)->parent));
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentClass.__Internal*)__Instance)->parent = ReferenceEquals(value, null) ? new global::NetVips.AutoGen.VipsArgument.__Internal() : *(global::NetVips.AutoGen.VipsArgument.__Internal*) value.__Instance;
            }
        }

        public global::NetVips.AutoGen.VipsObjectClass ObjectClass
        {
            get
            {
                global::NetVips.AutoGen.VipsObjectClass __result0;
                if (((global::NetVips.AutoGen.VipsArgumentClass.__Internal*) __Instance)->object_class == IntPtr.Zero) __result0 = null;
                else if (global::NetVips.AutoGen.VipsObjectClass.NativeToManagedMap.ContainsKey(((global::NetVips.AutoGen.VipsArgumentClass.__Internal*) __Instance)->object_class))
                    __result0 = (global::NetVips.AutoGen.VipsObjectClass) global::NetVips.AutoGen.VipsObjectClass.NativeToManagedMap[((global::NetVips.AutoGen.VipsArgumentClass.__Internal*) __Instance)->object_class];
                else __result0 = global::NetVips.AutoGen.VipsObjectClass.__CreateInstance(((global::NetVips.AutoGen.VipsArgumentClass.__Internal*) __Instance)->object_class);
                return __result0;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentClass.__Internal*)__Instance)->object_class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::NetVips.AutoGen.VipsArgumentFlags Flags
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsArgumentClass.__Internal*) __Instance)->flags;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentClass.__Internal*)__Instance)->flags = value;
            }
        }

        public int Priority
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsArgumentClass.__Internal*) __Instance)->priority;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentClass.__Internal*)__Instance)->priority = value;
            }
        }

        public uint Offset
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsArgumentClass.__Internal*) __Instance)->offset;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentClass.__Internal*)__Instance)->offset = value;
            }
        }
    }

    public unsafe partial class VipsArgumentInstance : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NetVips.AutoGen.VipsArgument.__Internal parent;

            [FieldOffset(8)]
            internal global::System.IntPtr argument_class;

            [FieldOffset(16)]
            internal global::System.IntPtr @object;

            [FieldOffset(24)]
            internal int assigned;

            [FieldOffset(28)]
            internal uint close_id;

            [FieldOffset(32)]
            internal uint invalidate_id;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NetVips.AutoGen.VipsArgumentInstance> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NetVips.AutoGen.VipsArgumentInstance>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::NetVips.AutoGen.VipsArgumentInstance __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::NetVips.AutoGen.VipsArgumentInstance(native.ToPointer(), skipVTables);
        }

        internal static global::NetVips.AutoGen.VipsArgumentInstance __CreateInstance(global::NetVips.AutoGen.VipsArgumentInstance.__Internal native, bool skipVTables = false)
        {
            return new global::NetVips.AutoGen.VipsArgumentInstance(native, skipVTables);
        }

        private static void* __CopyValue(global::NetVips.AutoGen.VipsArgumentInstance.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NetVips.AutoGen.VipsArgumentInstance.__Internal));
            *(global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VipsArgumentInstance(global::NetVips.AutoGen.VipsArgumentInstance.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VipsArgumentInstance(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        ~VipsArgumentInstance()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::NetVips.AutoGen.VipsArgumentInstance __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NetVips.AutoGen.VipsArgument Parent
        {
            get
            {
                return global::NetVips.AutoGen.VipsArgument.__CreateInstance(new global::System.IntPtr(&((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->parent));
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*)__Instance)->parent = ReferenceEquals(value, null) ? new global::NetVips.AutoGen.VipsArgument.__Internal() : *(global::NetVips.AutoGen.VipsArgument.__Internal*) value.__Instance;
            }
        }

        public global::NetVips.AutoGen.VipsArgumentClass ArgumentClass
        {
            get
            {
                global::NetVips.AutoGen.VipsArgumentClass __result0;
                if (((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->argument_class == IntPtr.Zero) __result0 = null;
                else if (global::NetVips.AutoGen.VipsArgumentClass.NativeToManagedMap.ContainsKey(((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->argument_class))
                    __result0 = (global::NetVips.AutoGen.VipsArgumentClass) global::NetVips.AutoGen.VipsArgumentClass.NativeToManagedMap[((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->argument_class];
                else __result0 = global::NetVips.AutoGen.VipsArgumentClass.__CreateInstance(((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->argument_class);
                return __result0;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*)__Instance)->argument_class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::NetVips.AutoGen.VipsObject Object
        {
            get
            {
                global::NetVips.AutoGen.VipsObject __result0;
                if (((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->@object == IntPtr.Zero) __result0 = null;
                else if (global::NetVips.AutoGen.VipsObject.NativeToManagedMap.ContainsKey(((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->@object))
                    __result0 = (global::NetVips.AutoGen.VipsObject) global::NetVips.AutoGen.VipsObject.NativeToManagedMap[((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->@object];
                else __result0 = global::NetVips.AutoGen.VipsObject.__CreateInstance(((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->@object);
                return __result0;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*)__Instance)->@object = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int Assigned
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->assigned;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*)__Instance)->assigned = value;
            }
        }

        public uint CloseId
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->close_id;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*)__Instance)->close_id = value;
            }
        }

        public uint InvalidateId
        {
            get
            {
                return ((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*) __Instance)->invalidate_id;
            }

            set
            {
                ((global::NetVips.AutoGen.VipsArgumentInstance.__Internal*)__Instance)->invalidate_id = value;
            }
        }
    }

    public unsafe partial class @object
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvips-42.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vips_argument_map")]
            internal static extern global::System.IntPtr VipsArgumentMap(global::System.IntPtr @object, global::System.IntPtr fn, global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvips-42.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vips_object_get_argument")]
            internal static extern int VipsObjectGetArgument(global::System.IntPtr @object, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr pspec, global::System.IntPtr argument_class, global::System.IntPtr argument_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvips-42.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vips_object_set_from_string")]
            internal static extern int VipsObjectSetFromString(global::System.IntPtr @object, [MarshalAs(UnmanagedType.LPStr)] string @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvips-42.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vips_type_map")]
            internal static extern global::System.IntPtr VipsTypeMap(ulong @base, global::System.IntPtr fn, global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvips-42.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vips_type_find")]
            internal static extern ulong VipsTypeFind([MarshalAs(UnmanagedType.LPStr)] string basename, [MarshalAs(UnmanagedType.LPStr)] string nickname);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvips-42.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vips_nickname_find")]
            internal static extern global::System.IntPtr VipsNicknameFind(ulong type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvips-42.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vips_object_print_all")]
            internal static extern void VipsObjectPrintAll();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvips-42.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vips_object_unref_outputs")]
            internal static extern void VipsObjectUnrefOutputs(global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvips-42.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vips_object_get_description")]
            internal static extern global::System.IntPtr VipsObjectGetDescription(global::System.IntPtr @object);
        }

        public static global::System.IntPtr VipsArgumentMap(global::NetVips.AutoGen.VipsObject @object, global::NetVips.AutoGen.VipsArgumentMapFn fn, global::System.IntPtr a, global::System.IntPtr b)
        {
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __arg1 = fn == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(fn);
            var __ret = __Internal.VipsArgumentMap(__arg0, __arg1, a, b);
            return __ret;
        }

        public static int VipsObjectGetArgument(global::NetVips.AutoGen.VipsObject @object, string name, global::NetVips.AutoGen.GParamSpec pspec, global::NetVips.AutoGen.VipsArgumentClass argument_class, global::NetVips.AutoGen.VipsArgumentInstance argument_instance)
        {
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __arg2 = ReferenceEquals(pspec, null) ? global::System.IntPtr.Zero : pspec.__Instance;
            var __arg3 = ReferenceEquals(argument_class, null) ? global::System.IntPtr.Zero : argument_class.__Instance;
            var __arg4 = ReferenceEquals(argument_instance, null) ? global::System.IntPtr.Zero : argument_instance.__Instance;
            var __ret = __Internal.VipsObjectGetArgument(__arg0, name, __arg2, __arg3, __arg4);
            return __ret;
        }

        public static int VipsObjectSetFromString(global::NetVips.AutoGen.VipsObject @object, string @string)
        {
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = __Internal.VipsObjectSetFromString(__arg0, @string);
            return __ret;
        }

        public static global::System.IntPtr VipsTypeMap(ulong @base, global::NetVips.AutoGen.VipsTypeMap2Fn fn, global::System.IntPtr a, global::System.IntPtr b)
        {
            var __arg1 = fn == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(fn);
            var __ret = __Internal.VipsTypeMap(@base, __arg1, a, b);
            return __ret;
        }

        public static ulong VipsTypeFind(string basename, string nickname)
        {
            var __ret = __Internal.VipsTypeFind(basename, nickname);
            return __ret;
        }

        public static string VipsNicknameFind(ulong type)
        {
            var __ret = __Internal.VipsNicknameFind(type);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static void VipsObjectPrintAll()
        {
            __Internal.VipsObjectPrintAll();
        }

        public static void VipsObjectUnrefOutputs(global::NetVips.AutoGen.VipsObject @object)
        {
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            __Internal.VipsObjectUnrefOutputs(__arg0);
        }

        public static string VipsObjectGetDescription(global::NetVips.AutoGen.VipsObject @object)
        {
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = __Internal.VipsObjectGetDescription(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static int VipsArgumentId
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("libvips", "_vips__argument_id");
                return *__ptr;
            }

            set
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("libvips", "_vips__argument_id");
                *__ptr = value;
            }
        }
    }
}
